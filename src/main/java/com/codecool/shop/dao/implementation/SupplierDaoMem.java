package com.codecool.shop.dao.implementation;import com.codecool.shop.dao.SupplierDao;import com.codecool.shop.model.Supplier;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class SupplierDaoMem implements SupplierDao {    private List<Supplier> DATA = new ArrayList<>();    private AtomicInteger maxId = new AtomicInteger(1);    private static SupplierDaoMem instance = null;    private static final Logger LOGGER = LoggerFactory.getLogger(SupplierDaoMem.class);    private SupplierDaoMem() {    }    public static SupplierDaoMem getInstance() {        if (instance == null) {            instance = new SupplierDaoMem();        }        return instance;    }    @Override    public void add(Supplier supplier) {        if ( supplier != null){            supplier.setId(maxId.getAndIncrement());            LOGGER.info("Supplier:( {} ) is added to DATA", supplier);            DATA.add(supplier);        }        else {            LOGGER.warn("Supplier is null");            throw new NullPointerException();        }    }    @Override    public Supplier find(int id) {        if (id <= maxId.intValue() && id >= 1 ) {            LOGGER.info("{} is a valid id", id);            return DATA.stream().filter(t -> t.getId() == id).findFirst().orElse(null);        } else {            LOGGER.warn("{} is not valid", id);            throw new IllegalArgumentException();        }    }    @Override    public void remove(int id) {        if(id >= 0) {            LOGGER.info("{} is removed", id);            DATA.remove(find(id));        } else {            LOGGER.warn("{} cannot be removed, because the id is not valid", id);            throw new IllegalArgumentException();        }    }    @Override    public List<Supplier> getAll() {        return DATA;    }}